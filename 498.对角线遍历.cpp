/*
 * @lc app=leetcode.cn id=498 lang=cpp
 *
 * [498] 对角线遍历

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

 

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

说明:

给定矩阵中的元素总数不会超过 100000 。

 */

/*
'''
每层的索引和相等：
1. 假设矩阵无限大；
2. 索引和为{偶}数，向上遍历，{横}索引值递减，遍历值依次是(x,0),(x-1,1),(x-2,2),...,(0,x)
3. 索引和为{奇}数，向下遍历，{纵}索引值递减，遍历值依次是(0,y),(1,y-1),(2,y-2),...,(y,0)

   每层的索引和:
            0:              (00)
            1:            (01)(10)
            2:          (20)(11)(02)
            3:        (03)(12)(21)(30)
            4:      (40)(31)(22)(13)(04)
            5:    (05)(14)(23)(32)(41)(50)
            6:  (60)(51)................(06)

        按照“层次”遍历，依次append在索引边界内的值即可
'''
*/
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        int m = matrix[0].size() - 1;   // 纵轴 索引最大值 m
        int n = matrix.size() - 1;      // 横轴 索引最大值 n
        int c = m + n + 1;              // 层数 等于 横纵最大索引之和 + 1
        for (int x = 0; x < c; x++) {
            if(x % 2 == 0) {    //索引和为{偶}数，向上遍历，{横}索引值递减，遍历值依次是(x,0),(x-1,1),(x-2,2),...,(0,x)，不要索引出界的，即可
                for (int i = x; i >= 0; i--) {
                    int j = x - i;
                    if (i <= n && j <= m)
                        res.push_back(matrix[i][j]);
                    else if (j > m)
                        break;
                }
            } else {            //索引和为{奇}数，向下遍历，{纵}索引值递减，遍历值依次是(0,y),(1,y-1),(2,y-2),...,(y,0)，不要索引出界的，即可
                for (int j = x; j >= 0; j--) {
                    int i = x - j;
                    if (i <= n && j <= m)
                        res.push_back(matrix[i][j]);
                    else if (i > n)
                        break;
                }
            }
        }
        return res;
    }
};

